{"type":"design-decision","symbol":"SummarySection","symbolType":"Architecture","section":"overview","content":"SummarySection is the abstraction used to convert structured ChunkFlavor objects into human-readable, LLM-optimized text. It contains SectionKey, Symbol, SymbolType, and SectionNormalizedText and replaces raw JSON embeddings."}
{"type":"design-decision","symbol":"ISummarySectionBuilder","symbolType":"Interface","section":"contract","content":"All ChunkFlavors implement ISummarySectionBuilder, exposing IEnumerable<SummarySection> BuildSections(). This ensures consistent chunk creation while allowing freedom in summarization strategy."}
{"type":"design-decision","symbol":"Symbol","symbolType":"Field","section":"naming-rationale","content":"Symbol represents the conceptual entity being described (e.g. Device, UserLoginFlow), not the C# class name. This allows the architecture to generalize beyond source code into workflows, policies, layouts, and more."}
{"type":"design-decision","symbol":"SymbolType","symbolType":"Field","section":"naming-rationale","content":"SymbolType describes the semantic role of the entity (Model, Manager, Policy, Layout) and intentionally decouples meaning from implementation detail like SubKind or file structure."}
{"type":"design-decision","symbol":"SectionNormalizedText","symbolType":"Field","section":"design-choice","content":"All titles, descriptions, and section classifications are embedded directly inside SectionNormalizedText to create self-contained, natural language chunks. This removes dependency on metadata at query time and improves LLM comprehension."}
{"type":"design-decision","symbol":"ChunkFlavor","symbolType":"Architecture","section":"design-role","content":"ChunkFlavors (Model, Manager, Repository, etc.) are responsible only for expressing semantic meaning via SummarySections. Chunking, embedding, and storage are delegated to a separate pipeline."}
{"type":"design-decision","symbol":"VectorChunking","symbolType":"Process","section":"flow","content":"The pipeline consumes SummarySections, estimates tokens, splits into RagChunks if needed, and populates RagVectorPayload records for persistence in the vector database."}
{"type":"design-decision","symbol":"LLMOptimization","symbolType":"Principle","section":"intent","content":"All output is optimized for human-like reasoning. Narrative-style content is prioritized over raw structural data to increase recall and matching accuracy in semantic search."}