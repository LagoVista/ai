[
  {
    "Id": "IDX-001",
    "Title": "DocId Generation Strategy",
    "Status": "Accepted",
    "Description": "The DocId is the stable identifier assigned to a document (i.e., a source file or artifact) within the indexing system. Each document may be split into multiple chunks, but all of those chunks share the same DocId. The DocId ensures consistent grouping, retrieval, and tracking across ingestion runs.",
    "Decision": {
      "UseDeterministicGuidV5Kind": "UUIDv5",
      "CanonicalStringPattern": "<RepoUrl>|<NormalizedPath>",
      "NormalizationRules": {
        "RepoUrl": "trim whitespace, lowercase, remove trailing slash",
        "Path": "use forward slashes, collapse duplicate slashes, lowercase"
      },
      "DocIdComputation": "UUIDv5(NamespaceCodeFiles, canonicalString)",
      "StorageType": "string",
      "StringFormat": "32 uppercase hexadecimal characters, no braces or hyphens",
      "UniquenessScope": "global across all indexed content",
      "PathChangeBehavior": "If canonical string changes (file moved/renamed), treat as new DocId (no aliasing)",
      "NamespaceGuidVersioning": "Single fixed namespace GUID for now; change only if canonical rules change"
    },
    "Rationale": "Provides stable, deterministic identifiers without requiring centralized state. GUID v5 aligns with existing code. Storing as string simplifies serialization and supports future flexibility. Excluding aliasing keeps the contract clean and deterministic. Ensures global uniqueness, avoiding collisions and simplifying tooling across all content.",
    "ResolvedQuestions": [
      {
        "Q": "Include OrgId in canonical string?",
        "Answer": "No"
      },
      {
        "Q": "Store DocId as string or Guid?",
        "Answer": "String, format uppercase, no hyphens"
      },
      {
        "Q": "Namespace GUID versioning?",
        "Answer": "Single fixed namespace for now"
      },
      {
        "Q": "Uniqueness scope?",
        "Answer": "Global"
      },
      {
        "Q": "File renamed/moved → new DocId or alias?",
        "Answer": "New DocId; aliasing handled externally if needed"
      }
    ]
  },

  {
    "Id": "IDX-002",
    "Title": "PointId Generation Strategy",
    "Status": "Accepted",
    "Description": "The PointId is the unique identifier assigned to each vector chunk in the vector database. It allows each chunk to be upserted, retrieved, updated, or deleted independently.",
    "Decision": {
      "PointIdType": "GUID",
      "StorageType": "string",
      "UniquenessScope": "global across all chunks",
      "SlugFormatUsed": "No custom slug, GUID only"
    },
    "Rationale": "Simplifies generation and avoids slug-format complexity. Aligns with Qdrant’s requirement that point IDs be integers or UUID strings. Human-readable metadata remains in other fields.",
    "ResolvedQuestions": []
  },
  {
    "Id": "IDX-003",
    "Title": "Canonical Path & BlobUri Normalization Rules",
    "Status": "Accepted",
    "Description": "Defines how we normalize file paths and blob URIs for consistency, deduplication, and deterministic ID generation.",
    "Decision": {
      "FirstPathSegment": "ProjectId provided at indexing setup",
      "UseForwardSlashes": true,
      "Lowercase": true,
      "CollapseRepeatedSlashes": true,
      "EnsureLeadingSlash": true,
      "BlobUriMirrorsPath": true,
      "ReservedPrefixEnforcement": false,
      "MovedFilePolicy": "New canonical path = new identity",
      "MaxPathLengthEnforced": false
    },
    "Rationale": "Stable normalized paths avoid separator/case variation; project identifier provides portability; prefix enforcement avoided for flexibility; storage limits are high so no cap now.",
    "ResolvedQuestions": [
      {
        "Q": "Strip extensions for Title/ComponentName?",
        "Answer": "No"
      },
      {
        "Q": "Enforce reserved path prefixes?",
        "Answer": "No"
      },
      {
        "Q": "Enforce maximum path length?",
        "Answer": "No, defer"
      },
      {
        "Q": "If file moved/renamed, preserve old path segment?",
        "Answer": "No"
      }
    ]
  },
  {
    "Id": "IDX-004",
    "Title": "Kind & SubKind Classification Rules",
    "Status": "Accepted",
    "Description": "Kind classifies each document/chunk broadly; SubKind gives a more specific role under Kind. Both are required fields and values are free-form for now using PascalCase.",
    "Decision": {
      "KindField": "required",
      "SubKindField": "required",
      "NamingConvention": "PascalCase",
      "VocabularyControlled": false
    },
    "Rationale": "Two-level classification gives better granularity; PascalCase aligns with .NET naming conventions; free-form initially gives flexibility.",
    "ResolvedQuestions": [
      {
        "Q": "Should we have Kind + SubKind?",
        "Answer": "Yes"
      },
      {
        "Q": "Should SubKind be required?",
        "Answer": "Yes"
      },
      {
        "Q": "Naming convention?",
        "Answer": "PascalCase"
      },
      {
        "Q": "Controlled vocabulary now?",
        "Answer": "No, free-form for now"
      }
    ]
  },
  {
    "Id": "IDX-005",
    "Title": "ContentType / ContentTypeId Rules",
    "Status": "Accepted",
    "Description": "ContentType and ContentTypeId classify each document/chunk at a technical level (e.g., source code vs markdown vs HTML).",
    "Decision": {
      "ContentTypeIdEnum": "RagContentType",
      "ContentTypeString": "same name as enum value",
      "FieldsRequired": [ "ContentTypeId", "ContentType" ],
      "SemanticCategoriesUsed": true,
      "NamingConvention": "PascalCase",
      "SingleValueOnly": true,
      "VersionModifiersAllowed": false
    },
    "Rationale": "Numeric ID plus descriptive string supports readable and efficient metadata; semantic categories simplify mapping; PascalCase aligns with .NET conventions.",
    "ResolvedQuestions": [
      {
        "Q": "Initial set of values?",
        "Answer": "Defined via enum"
      },
      {
        "Q": "Reflect semantics vs file extensions?",
        "Answer": "Semantics"
      },
      {
        "Q": "Multiple content types per item?",
        "Answer": "No"
      },
      {
        "Q": "Version/variant in ContentType string?",
        "Answer": "No"
      },
      {
        "Q": "Naming convention?",
        "Answer": "PascalCase"
      }
    ]
  },
  {
    "Id": "IDX-006",
    "Title": "Subtype Rules",
    "Status": "Accepted",
    "Description": "The SubKind metadata field provides specific classification under Kind (e.g., for Kind=Code: Manager, Repository, Model, PrimitiveComponent).",
    "Decision": {
      "KindField": "required",
      "SubKindField": "required",
      "NamingConvention": "PascalCase",
      "VocabularyControlled": false,
      "SingleValueOnly": true,
      "VersionModifiersAllowed": false,
      "GlobalUniquenessOfSubKind": false,
      "RuntimeKindSubKindValidation": false
    },
    "Rationale": "Two-level classification gives granularity without explosion of top-level kinds; PascalCase aligns with .NET naming; free-form initially gives flexibility until glossary defined.",
    "ResolvedQuestions": [
      {
        "Q": "Glossary formalization process?",
        "Answer": "Deferred"
      },
      {
        "Q": "Version modifiers in SubKind?",
        "Answer": "No"
      },
      {
        "Q": "Is SubKind optional?",
        "Answer": "No, required (\"None\" accepted)"
      },
      {
        "Q": "Are SubKind values globally unique?",
        "Answer": "No"
      },
      {
        "Q": "Runtime validation of Kind+SubKind?",
        "Answer": "No"
      }
    ]
  },
  {
    "Id": "IDX-007",
    "Title": "Domain / Layer / Role Semantics",
    "Status": "Accepted",
    "Description": "The metadata fields Domain, Layer and Role provide orthogonal classification axes to describe where and how a document fits in the system architecture.",
    "Decision": {
      "FieldsOptionalForNonCode": true,
      "FieldsRequiredForCode": true,
      "NamingConvention": "PascalCase",
      "FreeFormValues": true,
      "SingleRoleOnly": true,
      "LayerFreeForm": true,
      "RoleNamesReusableAcrossDomains": true,
      "IngestionLogicEnforcementDeferred": true
    },
    "Rationale": "Optional for non-code keeps metadata light; PascalCase aligns with conventions; free-form values allow agility; single role simplifies classification; reuse across domains is logical.",
    "ResolvedQuestions": [
      {
        "Q": "Controlled vocabulary?",
        "Answer": "No"
      },
      {
        "Q": "Multiple Role values?",
        "Answer": "No, only one"
      },
      {
        "Q": "Ingestion logic enforcement?",
        "Answer": "Deferred"
      },
      {
        "Q": "Layer ordering?",
        "Answer": "No, free-form"
      },
      {
        "Q": "Are Role names globally unique?",
        "Answer": "No"
      }
    ]
  },
  {
    "Id": "IDX-008",
    "Title": "SymbolType Rules",
    "Status": "Accepted",
    "Description": "The SymbolType metadata field classifies the nature of the symbol a chunk represents (e.g., file, component, method).",
    "Decision": {
      "SymbolTypeFieldRequiredForCode": true,
      "NamingConvention": "PascalCase",
      "TopLevelSymbolTypeForFile": "File",
      "SingleValueOnly": true,
      "ControlledVocabulary": false,
      "GlobalUniquenessOfSymbolType": "Deferred",
      "RuntimeKindSymbolTypeValidation": "Deferred"
    },
    "Rationale": "Optional for non-code assets keeps metadata simpler; PascalCase aligns with metadata conventions; File as top level symbol gives predictability; free-form now allows flexibility.",
    "ResolvedQuestions": [
      {
        "Q": "File-level chunks need special SymbolType?",
        "Answer": "Yes – File"
      },
      {
        "Q": "Multiple symbol types per chunk?",
        "Answer": "No"
      },
      {
        "Q": "SymbolType values globally unique?",
        "Answer": "Deferred"
      },
      {
        "Q": "Translate chunker SymbolType or mirror?",
        "Answer": "No – minimal mapping"
      },
      {
        "Q": "Pre-define SymbolTypes for non-code assets now?",
        "Answer": "Deferred"
      }
    ]
  },
  {
    "Id": "IDX-009",
    "Title": "ComponentType & ComponentName Rules",
    "Status": "Preliminary",
    "Description": "ComponentType and ComponentName provide specialized classification for component-oriented artifacts (primitive/composite) and the specific component name.",
    "Decision": {
      "ComponentTypeField": "populated only for component artifacts",
      "ComponentTypeValues": [ "primitive", "composite", "other" ],
      "ComponentTypeNaming": "lowercase",
      "ComponentNameField": "populated only for component artifacts",
      "ComponentNameNaming": "PascalCase",
      "DefaultComponentTypeIfUndetermined": "other"
    },
    "Rationale": "Distinguishing primitive vs composite components enables meaningful filtering; ComponentName aligned to code symbol improves traceability; restricting values supports consistency; fields optional for non-component artifacts.",
    "ResolvedQuestions": [
      {
        "Q": "Extend ComponentType taxonomy?",
        "Answer": "No"
      },
      {
        "Q": "Composite components classification?",
        "Answer": "composite"
      },
      {
        "Q": "ComponentName include namespace?",
        "Answer": "No"
      },
      {
        "Q": "Platform-agnostic component classification?",
        "Answer": "Handled in other metadata"
      },
      {
        "Q": "For non-component artifacts should these fields be omitted?",
        "Answer": "Yes"
      }
    ]
  },
  {
    "Id": "IDX-010",
    "Title": "LabelSlugs & LabelIds Semantics",
    "Status": "Accepted",
    "Description": "LabelSlugs and LabelIds provide tagging metadata for each chunk/document, enabling richer filtering and categorization.",
    "Decision": {
      "LabelSlugsRequired": true,
      "LabelIdsRequired": true,
      "LabelSlugsNaming": "lowercase-hyphen-separated",
      "LabelIdsFormat": "uppercase alphanumeric with prefix",
      "AlignSlugsAndIds": true,
      "FreeFormTags": true,
      "AvoidDuplicates": true,
      "FlatTagsOnly": true,
      "NoMaxLabels": true,
      "IdsScopedPerProject": true
    },
    "Rationale": "Tagging supports flexible metadata; slug naming improves uniformity; stable IDs support backend tooling; flat tags simplify ingestion; free-form initially allows agility.",
    "ResolvedQuestions": [
      {
        "Q": "Controlled vocabulary now?",
        "Answer": "No"
      },
      {
        "Q": "Max number of labels?",
        "Answer": "No"
      },
      {
        "Q": "LabelIds globally unique?",
        "Answer": "No"
      },
      {
        "Q": "Hierarchical slugs allowed?",
        "Answer": "No, flat only"
      },
      {
        "Q": "Track label timestamp/version?",
        "Answer": "No"
      }
    ]
  },
  {
    "Id": "IDX-011",
    "Title": "Priority System",
    "Status": "Accepted",
    "Description": "The Priority field denotes relative importance of a chunk/document (lower = higher priority).",
    "Decision": {
      "Range": "1–10",
      "TailoredPerAssetKind": true,
      "IntegerOnly": true,
      "DynamicAdjustmentsAllowed": true
    },
    "Rationale": "A 1-10 integer scale provides granularity; tailored heuristics per asset kind improve relevance; integer simplifies logic; dynamic updates allow evolving importance.",
    "ResolvedQuestions": [
      {
        "Q": "Exact integer range?",
        "Answer": "1–10"
      },
      {
        "Q": "Define each numeric level now?",
        "Answer": "To be documented later"
      },
      {
        "Q": "Separate scales per asset kind?",
        "Answer": "Yes, allowed"
      },
      {
        "Q": "Fractional values allowed?",
        "Answer": "No"
      },
      {
        "Q": "Priority immutable?",
        "Answer": "No, adjustable"
      }
    ]
  },
  {
    "Id": "IDX-012",
    "Title": "JSON Field Naming Convention",
    "Status": "Accepted",
    "Description": "Defines naming style and field-presence rules for JSON metadata payloads.",
    "Decision": {
      "NamingConvention": "PascalCase",
      "ExactMatchToCSharpPropertyNames": true,
      "NullValuedFieldsStrategy": "OmitProperties",
      "NoAliasesForBackwardCompatibility": true,
      "ClientLayerCasingTransformsAllowed": true
    },
    "Rationale": "Matching C# names simplifies serialization; single naming style avoids confusion; omitting null fields reduces payload size and indicates non-applicability; optional fields prevalent so omission is leaner.",
    "ResolvedQuestions": [
      {
        "Q": "Allow aliasing of keys for backward compatibility?",
        "Answer": "No"
      },
      {
        "Q": "Null-valued properties: include or omit?",
        "Answer": "Omit"
      },
      {
        "Q": "Client‐level casing differences handled where?",
        "Answer": "At client layer, not storage schema"
      }
    ]
  },
  {
    "Id": "IDX-013",
    "Title": "UpdatedUtc Logic",
    "Status": "Accepted",
    "Description": "The UpdatedUtc field (source modification timestamp) is removed from the metadata contract; indexing only on required content changes so this field is unnecessary now.",
    "Decision": {
      "RemoveField": "UpdatedUtc",
      "Rationale": "Simplifies metadata model; indexing control handles re-indexing when needed; keeps payload lean.",
      "FutureConsideration": "Field retained as placeholder if incremental update or auditing becomes required"
    }
  },
  {
    "Id": "IDX-014",
    "Title": "Token Field Definitions",
    "Status": "Accepted",
    "Description": "The fields EstimatedTokens, ChunkSizeTokens and OverlapTokens capture chunk size and overlap metrics for embedding and indexing.",
    "Decision": {
      "EstimatedTokensRequired": true,
      "ChunkSizeTokensOptional": true,
      "OverlapTokensOptional": true,
      "NamingConvention": "PascalCase",
      "UseCases": [ "analytics", "costEstimation", "chunkStrategyTuning" ],
      "MaxTokenThresholdEnforced": "Deferred",
      "OverlapValidation": "None",
      "LineBasedChunkersMustEstimateTokens": true
    },
    "Rationale": "Estimating token size aids monitoring and cost analysis; requiring EstimatedTokens ensures baseline size metric; optional actual/overlap fields add richness; naming consistency maintained.",
    "ResolvedQuestions": [
      {
        "Q": "Max token threshold enforcement?",
        "Answer": "Deferred"
      },
      {
        "Q": "Validate overlap smaller than chunk size?",
        "Answer": "No enforcement now"
      },
      {
        "Q": "Line-based chunker scenario—EstimatedTokens?",
        "Answer": "Still compute estimate"
      },
      {
        "Q": "Enforce rounding/truncation of token counts?",
        "Answer": "No"
      },
      {
        "Q": "Track token budget vs model usage separately?",
        "Answer": "No (may revisit)"
      }
    ]
  },
  {
    "Id": "IDX-015",
    "Title": "SourceSha256 Rules",
    "Status": "Deprecated",
    "Description": "The SourceSha256 field (document-level hash) is removed from the metadata contract; change detection will rely on ContentHash.",
    "Decision": {
      "RemoveField": "SourceSha256",
      "ChangeDetectionVia": "ContentHash only",
      "LegacyRetention": "Existing data may contain field but new ingestion ignores it"
    },
    "Rationale": "Document-level hash redundant under full-file re-index strategy; reduces metadata complexity; aligns with ingestion workflow."
  },
  {
    "Id": "IDX-016",
    "Title": "ContentHash Rules",
    "Status": "Accepted",
    "Description": "ContentHash stores the SHA-256 hash of the normalized text content of a chunk (or file-level chunk) for change detection and indexing triggers.",
    "Decision": {
      "FieldRequired": true,
      "Algorithm": "SHA-256",
      "HashFormat": "64-hex lowercase",
      "NormalizedTextContentOnly": true,
      "DropDocumentLevelHash": true,
      "ChangeTriggerOnHashMismatch": true,
      "ChunkingLogicStabilityRequired": true
    },
    "Rationale": "A single content hash simplifies change detection; SHA-256 provides strong integrity; dropping document-level hash reduces redundancy given our full-file-reindex strategy; line ending normalization ensures cross-platform determinism.",
    "ResolvedQuestions": [
      {
        "Q": "Always use SHA-256?",
        "Answer": "Yes"
      },
      {
        "Q": "Chunking/normalization change handling?",
        "Answer": "Full re-index triggered"
      },
      {
        "Q": "Chunk identity when PartIndex changes?",
        "Answer": "Chunking logic must remain stable; if not treat as changed"
      },
      {
        "Q": "Include embedding vector/metadata in hash?",
        "Answer": "No"
      },
      {
        "Q": "Timestamp when hash computed?",
        "Answer": "No"
      }
    ]
  },
  {
    "Id": "IDX-017",
    "Title": "BlobVersionId Rules",
    "Status": "Accepted",
    "Description": "The BlobVersionId field will be optional and unused for version‐tracking; indexing logic relies on fresh content and content‐hash workflows.",
    "Decision": {
      "FieldOptional": true,
      "UseForVersioning": false,
      "CaptureIfAvailable": true,
      "ChangeDetectionVia": "ContentHash only"
    },
    "Rationale": "Workflow uses latest blob content only; version IDs add complexity without benefit; decouples storage versioning from indexing logic.",
    "ResolvedQuestions": [
      {
        "Q": "Require BlobVersionId when storage supports versioning?",
        "Answer": "No"
      },
      {
        "Q": "Store version timestamp alongside ID?",
        "Answer": "No"
      },
      {
        "Q": "Handle storage versioning disabled?",
        "Answer": "N/A to logic"
      },
      {
        "Q": "Use version ID in DocId/PointId?",
        "Answer": "No"
      },
      {
        "Q": "Special treatment when blob overwritten without versioning?",
        "Answer": "No"
      }
    ]
  },
  {
    "Id": "IDX-018",
    "Title": "PDF / HTML Mapping",
    "Status": "Proposed",
    "Description": "Optional mapping fields PdfPages and HtmlAnchor enable linking vector chunks to their source location in PDF or HTML documents.",
    "Decision": {
      "PdfPagesOptional": true,
      "HtmlAnchorOptional": true,
      "PopulateIfAvailable": true,
      "DoesNotBlockIndexingOnMissing": true
    },
    "Rationale": "Allows improved navigation to source context for PDF/HTML assets; optional fields keep contract lean for other asset types.",
    "ResolvedQuestions": [
      {
        "Q": "Require at least one mapping for PDF/HTML assets?",
        "Answer": "Deferred"
      },
      {
        "Q": "PdfPages support ranges vs list?",
        "Answer": "Deferred"
      },
      {
        "Q": "HtmlAnchor include full URL or just fragment?",
        "Answer": "Deferred"
      },
      {
        "Q": "Prioritise PDF vs HTML when both exist?",
        "Answer": "Deferred"
      },
      {
        "Q": "Link both page and anchor when possible?",
        "Answer": "Deferred"
      }
    ]
  },
  {
    "Id": "IDX-019",
    "Title": "PartIndex / PartTotal Guarantees",
    "Status": "Accepted",
    "Description": "PartIndex (1-based) and PartTotal (total chunks) provide ordering and completeness metadata for each chunk.",
    "Decision": {
      "PartIndexRequired": true,
      "PartTotalRequired": true,
      "IndexBase": "1",
      "Guarantee": "1 ≤ PartIndex ≤ PartTotal",
      "SamePartTotalAcrossChunks": true,
      "SimpleDeterministicSystem": true
    },
    "Rationale": "Ordering and completeness metadata simplifies tooling; 1-based indexing aligns with intuitive user interfaces; deterministic assignment supports reliable ingestion workflows."
  },
  {
    "Id": "IDX-020",
    "Title": "LineStart / LineEnd Expectations",
    "Status": "Accepted",
    "Description": "LineStart and LineEnd denote the inclusive 1-based line number range a chunk covers in the source document; CharStart/CharEnd optional offsets. Additional rule: any source line >500 characters is truncated at 500 chars before chunking.",
    "Decision": {
      "LineStartRequiredForText": true,
      "LineEndRequiredForText": true,
      "LineBase": "1",
      "LineEndGreaterOrEqualStart": true,
      "CharOffsetsOptional": true,
      "MaxLineSpanEnforced": false,
      "MidLineSplitAllowed": { "LineEndEqualsLineStart": true },
      "TruncateSourceLineMaxChars": 500
    },
    "Rationale": "Line boundaries improve traceability; requiring them for text ensures consistency; mid-line splits supported; truncation of excessively long lines protects embedding budgets and chunking logic."
  },
  {
    "Id": "IDX-021",
    "Title": "CharStart / CharEnd Semantics",
    "Status": "Accepted",
    "Description": "CharStart and CharEnd define 0-based inclusive character offset range within normalized source text for the chunk.",
    "Decision": {
      "CharStartOptional": true,
      "CharEndOptional": true,
      "CharStartMin": 0,
      "CharEndMinCharStart": true,
      "OffsetsBasedOnNormalizedText": true,
      "MidLineSplitPermitted": true,
      "SubstringMustMatchTextNormalized": true
    },
    "Rationale": "Character offsets provide precise location pointers for advanced tooling; optionality keeps the model flexible; inclusive range avoids ambiguity on boundaries.",
    "ResolvedQuestions": [
      {
        "Q": "Require offsets for all text-based chunks?",
        "Answer": "No"
      },
      {
        "Q": "Inclusive definition if splitting mid-char?",
        "Answer": "Inclusive"
      },
      {
        "Q": "Should substring match exactly?",
        "Answer": "Yes"
      },
      {
        "Q": "Enforce rounding/truncation on offsets?",
        "Answer": "No"
      },
      {
        "Q": "Compute offsets only above token threshold?",
        "Answer": "No"
      }
    ]
  },
  {
    "Id": "IDX-022",
    "Title": "How We Store Example Values in Spec",
    "Status": "Proposed",
    "Description": "Guidelines for including and formatting example values in the spec (markdown and JSON L) and long-term plan to harvest live data.",
    "Decision": {
      "ProvideInlineExamples": true,
      "MatchSerializationFormat": true,
      "IncludeExamplesAttributeInJSONL": true,
      "EnsureConsistencyAcrossExamples": true,
      "LongTermPlan": "Harvest live data from vector DB to populate real examples"
    },
    "Rationale": "Using illustrative values improves comprehension, tooling support and spec clarity; aligning with serialization format reduces mistakes; live-data examples increase realism and adherence to specification best practices."
  },
  {
    "Id": "IDX-023",
    "Title": "ExternalId Field Strategy",
    "Status": "Accepted",
    "Description": "ExternalId is an optional external locator for chunk/document; flexible format, no uniqueness or versioning required.",
    "Decision": {
      "FieldOptional": true,
      "FormatEnforced": false,
      "UniquenessRequired": false,
      "PopulateWhenUnavailable": false,
      "MandatoryForClients": false,
      "VersioningRequired": false
    },
    "Rationale": "Flexible external references support diverse use-cases; keeping it auxiliary avoids complicating core indexing logic."
  },
  {
    "Id": "IDX-024",
    "Title": "SubKind Definitions for Server Code Base",
    "Status": "Accepted",
    "Description": "Defines the semantic SubKind values and their categorization for server-side C# source files.",
    "Decision": {
      "SubKinds": [ "DomainDescription", "Model", "Manager", "Repository", "Controller", "Service", "Interface", "Other" ],
      "PriorityOrder": [ "DomainDescription", "Model", "Manager", "Repository", "Controller", "Service", "Interface", "Other" ],
      "SymbolTypeMapping": {
        "classes": "component",
        "interfaces": "interface"
      },
      "ChunkingStrategyVaries": true,
      "MixedPurposeClassesFlagged": true,
      "AutoReclassification": false,
      "UnmappedFilesManualReview": false,
      "ExtensibilityOfSubKindList": false
    },
    "Rationale": "Controlled SubKind values enable richer metadata filtering; clear heuristics reduce ambiguity in classification; supports search, analytics and code-understanding workflows."
  },
  {
    "Id": "IDX-030",
    "Title": "Local Indexing & Persisted SubKind Override",
    "Status": "Accepted",
    "Description": "Defines local index store for file metadata including ContentHash & SubKind, and change-detection logic using Reindex directives.",
    "Decision": {
      "RecordFields": [ "FilePath", "DocId", "ContentHash", "SubKind", "LastIndexedUtc", "FlagForReview", "Reindex" ],
      "ReuseIfHashAndSubKindMatch": true,
      "ReindexValues": [ "chunk", "full" ],
      "OverrideStoredSubKindPreferred": true,
      "ManualOverrideSetsReindex": "chunk",
      "FlagMixedOrUnmapped": true,
      "LightweightStore": true
    },
    "Rationale": "Ensures efficient ingestion by skipping unchanged files; supports manual override and re-classification; gives control over chunking/embedding via Reindex field."
  },
  {
    "Id": "IDX-031",
    "Title": "SubKind Heuristics & Detection Rules",
    "Status": "Accepted",
    "Description": "Detection heuristics and rules for classifying server-side C# source files into SubKinds, using attributes, base class, interface name, namespace/folder patterns.",
    "Decision": {
      "HeuristicOrder": [ "DomainDescription", "Model", "Manager", "Repository", "Controller", "Service", "Interface", "Other" ],
      "DetectionCriteria": {
        "DomainDescription": [ "AttributeDomainDescriptor", "AttributeDomainDescription", "NamespaceIncludes(.Domain|.Descriptors)" ],
        "Model": [ "AttributeEntityDescription", "InheritsEntityBase", "NamespaceIncludes(Models)" ],
        "Manager": [ "ImplementsI*Manager", "InheritsManagerBase", "NamespaceIncludes(Managers)" ],
        "Repository": [ "InheritsDocumentDBRepoBase", "InheritsTableStorageBase", "ImplementsI*Repository", "NamespaceIncludes(Repositories)" ],
        "Controller": [ "InheritsLagoVistaBaseController", "NamespaceIncludes(Controllers)", "HasAttributeApiController" ],
        "Service": [ "ImplementsI*Service", "NamespaceIncludes(Services)", "NotMatchedHigherHeuristics" ],
        "Interface": [ "TypeIsInterface", "NameStartsWithI" ],
        "Other": []
      },
      "SymbolTypeMapping": {
        "classes": "component",
        "interfaces": "interface"
      },
      "ChunkingStrategyVaries": true,
      "FlagOtherOrMixed": true
    },
    "Rationale": "Systematic classification of legacy code base supports richer metadata filtering; adaptable chunking per artifact type; enables tooling and analytics over role-based categories."
  },
  {
    "Id": "IDX-033",
    "Title": "Metadata Registry & Facet Discovery",
    "Status": "Accepted",
    "Description": "After each indexing run, the ingestor reports unique facet values and combinations (e.g., Kind, SubKind, ChunkFlavor, Repo, Domain) to a server-side Metadata Registry.",
    "Decision": {
      "SyncMode": "batch-at-end-of-run",
      "FacetEligibleFields": [ "Kind", "SubKind", "ChunkFlavor", "Repo", "Domain", "Layer", "Role", "ComponentType", "ComponentName", "ContentType", "ContentTypeId" ],
      "SingleFacetShape": {
        "Property": "string",
        "Value": "string"
      },
      "ComboFacetShape": {
        "Dimensions": [
          {
            "Property": "string",
            "Value": "string"
          }
        ]
      },
      "Examples": [ "Kind=SourceCode", "Kind=SourceCode,SubKind=Model", "Kind=SourceCode,SubKind=Model,ChunkFlavor=Raw" ],
      "ClientGuarantees": [ "unique-per-run", "no-global-state" ],
      "ServerResponsibilities": [ "dedupe", "persist", "use-for-filters-and-analytics" ]
    },
    "Rationale": "Keeps ingestion lightweight and local while enabling a central registry to drive filters, analytics, and UI facets over vector metadata."
  },
  {
    "Id": "IDX-0034",
    "Title": "Deletion of Stale Chunks",
    "Status": "Accepted",
    "Description": "Defines when and how vector chunks are considered stale and must be removed from the vector database whenever a document is re-indexed.",
    "Decision": {
      "StaleChunkDefinition": "Any existing chunk in the vector store whose payload DocId matches a document being re-indexed in the current run but is not part of the newly generated chunk set.",
      "DocScopeForDeletion": "Per DocId; only DocIds processed during the current run are eligible for stale-chunk deletion.",
      "DeletionStrategy": "Replace-all-per-DocId",
      "DeletionMechanism": "Before inserting new chunks for a DocId, delete all existing chunks where payload.DocId equals that DocId using a delete-by-filter operation.",
      "UpsertStrategyForNewChunks": "Insert all newly-generated chunks after deletion, each with a fresh PointId.",
      "NoFineGrainedDiffing": true,
      "ContentHashRelationship": "ContentHash determines whether the file needs re-indexing; once triggered, all chunks for that DocId are stale regardless of individual chunk hashes.",
      "ReindexFlagRelationship": {
        "WhenReindexIsNoneOrMissing": "If the local index indicates no change, the file is skipped and existing chunks remain untouched.",
        "WhenReindexIsChunkOrFull": "The file is re-chunked and re-embedded; all previous chunks for that DocId are deleted and replaced."
      },
      "DryRunBehavior": "Dry-run mode reports which DocIds would be deleted and how many chunks, but performs no changes.",
      "NonTextAssets": "Non-text assets use the same delete-and-replace strategy.",
      "ConcurrencyAndConsistencyScope": "After a successful run, there is at most one generation of chunks per DocId; temporary internal duplication is not part of the external contract."
    },
    "Rationale": "Using DocId as the ownership boundary simplifies ingestion and ensures deterministic deletion of outdated chunks. Replace-all-per-DocId avoids diffing complexity and guarantees no orphaned or stale chunks remain. The local index controls re-index triggers; once engaged, deletion is unconditional.",
    "ResolvedQuestions": [
      {
        "Q": "Do we ever attempt fine-grained diffing to preserve chunks?",
        "Answer": "No."
      },
      {
        "Q": "Do we delete chunks for DocIds not processed in this run?",
        "Answer": "No."
      },
      {
        "Q": "Are PointIds stable across re-indexing?",
        "Answer": "No."
      },
      {
        "Q": "Does chunk-level ContentHash affect deletion?",
        "Answer": "No; decisions occur at the file level only."
      }
    ]
  },
  {
    "Id": "IDX-0035",
    "Title": "Deletion of Chunks When Local File No Longer Exists",
    "Status": "Accepted",
    "Description": "Defines how to delete chunks from the vector database when a previously-indexed file no longer exists in the current filesystem or project during an indexing run.",
    "Decision": {
      "DetectionRule": "A file is orphaned when it exists in the local index but does not exist on disk at its recorded path.",
      "DeletionStrategy": "Delete all chunks whose payload.DocId matches the orphaned file's DocId, then remove the file's record from the local index.",
      "ReplacementPolicy": "No replacement chunks are created; this is a pure deletion operation.",
      "TriggerConditions": [ "File missing from filesystem", "File moved or renamed", "File excluded by filters", "File outside project scope" ],
      "FilterEquivalenceRule": "Files excluded by ignore rules or filters are treated as missing.",
      "DryRunBehavior": "Report candidate DocIds and chunk counts but do not modify vector DB or local index.",
      "DeterminismGuarantee": "After a successful run, no chunks exist for any file missing from the filesystem."
    },
    "Rationale": "Ensures vector DB and local index remain consistent with the actual filesystem. Missing files must be fully removed to avoid orphaned chunks and stale search results. Treating deletions, renames, moves, and filter-driven exclusions uniformly simplifies logic and maintains determinism.",
    "ResolvedQuestions": [
      {
        "Q": "Recover renamed files?",
        "Answer": "No; renames create new DocIds per canonical path rules."
      },
      {
        "Q": "Delete chunks for filter-excluded files?",
        "Answer": "Yes; exclusion is treated as deletion for indexing purposes."
      },
      {
        "Q": "Depend on ContentHash or Reindex flags?",
        "Answer": "No; missing-file detection overrides all other signals."
      },
      {
        "Q": "Retain records for historical tracking?",
        "Answer": "No; local index contains only currently-present files."
      }
    ]
  },
  {
    "Id": "IDX-0036",
    "Title": "Local Index File Format & Maintenance Rules",
    "Status": "Accepted",
    "Description": "Defines the JSON structure, update rules, and lifecycle behavior of the local index used to determine re-indexing, SubKind overrides, missing-file cleanup, and which files are active for LLM inclusion.",
    "Decision": {
      "RecordShape": {
        "FilePath": "string",
        "DocId": "string",
        "ContentHash": "string",
        "ActiveContentHash": "string or null",
        "SubKind": "string or null",
        "LastIndexedUtc": "ISO-8601",
        "FlagForReview": "boolean or null",
        "Reindex": "null | \"chunk\" | \"full\""
      },
      "ContentHashSemantics": "Hash of the last content successfully indexed into the vector DB.",
      "ActiveContentHashSemantics": "Hash of the current on-disk content; mismatch indicates the file is Active and should be sent directly to the LLM.",
      "Location": "<project-root>/.nuvos/index/local-index.json",
      "StartupRules": [ "Load if exists", "If corrupt rename and start fresh", "If missing start empty" ],
      "ProcessingRules": {
        "ComputeActiveContentHash": true,
        "ActiveDetection": "Active when ActiveContentHash != ContentHash",
        "PersistSubKindOverride": true
      },
      "MissingFileBehavior": "Delete all DocId chunks and remove record.",
      "AfterSuccessfulIngestion": [ "Set ContentHash = ActiveContentHash", "Update LastIndexedUtc", "Apply SubKind if no override", "Clear Reindex" ],
      "WriteFrequency": "Write index after every file using atomic write.",
      "Atomicity": [ "Write to temp file", "Atomic replace" ],
      "Sorting": "Entries sorted by FilePath ascending",
      "SafetyGuarantees": [ "No entries for missing files", "Canonical paths only", "ContentHash always last-indexed content", "ActiveContentHash always current content", "SubKind overrides persist", "Reindex cleared after ingestion", "Crash-safe because index is saved per-file" ]
    },
    "Rationale": "Writing after every file ensures crash-safe recovery and accurate incremental processing. Distinguishing between ContentHash and ActiveContentHash enables downstream LLM orchestration to know which files require direct context injection versus those already reflected in the vector DB.",
    "ResolvedQuestions": [
      {
        "Q": "Does indexing clear Active status?",
        "Answer": "Yes, by setting ContentHash = ActiveContentHash."
      },
      {
        "Q": "Historical metadata for missing files retained?",
        "Answer": "No."
      },
      {
        "Q": "Do SubKind overrides persist?",
        "Answer": "Yes."
      },
      {
        "Q": "Track OS file metadata?",
        "Answer": "No."
      },
      {
        "Q": "Multiple index files supported?",
        "Answer": "No."
      }
    ]
  },
  {
    "Id": "NOTE-ENTITY-EXTRACTOR-001",
    "Title": "How to Build ModelStructureDescription from C# Attributes",
    "Kind": "ImplementationHint",
    "RelatedTo": [ "IDX-0037", "IDX-0038" ],
    "Description": "High-level guidance for extracting ModelStructureDescription from existing C# EntityDescription/FormField/Resource attributes and resource dictionaries.",
    "Details": {
      "ClassLevel": {
        "Attribute": "EntityDescription",
        "Purpose": "Source of high-level entity metadata and URLs.",
        "FieldsToUse": [ "TitleResource", "HelpResource", "DescriptionResource", "Domain", "ListUIUrl", "EditUIUrl", "CreateUIUrl", "HelpUrl", "InsertUrl", "SaveUrl", "UpdateUrl", "FactoryUrl", "GetUrl", "GetListUrl", "DeleteUrl", "ResourceLibrary" ],
        "Processing": "Read EntityDescription via reflection, resolve Title/Help/Description from the specified resource library using the provided resource keys, and map URLs directly into ModelStructureDescription fields."
      },
      "PropertyLevel": {
        "PrimaryAttribute": "FormField",
        "OptionalAttributes": [ "HelpResource", "LabelResource", "FKeyProperty" ],
        "ResourceUsage": "FormField.ResourceType indicates which resource library to use. LabelResource and HelpResource hold keys into that library for display name and description of the field.",
        "StructuralDetection": [ "Determine LanguageType from property type.", "Set IsCollection for List<T> / arrays.", "Set IsNullable based on type and nullability.", "Set IsEnum when the type or underlying generic argument is an enum." ],
        "EntityHeaderDetection": [ "Detect EntityHeader<T> and List<EntityHeader<T>>.", "Set TargetType = T.", "Set IsEnumHeader when T is an enum.", "Attach FactoryUrl when present (used to create child records).", "If FKeyProperty is present, set HasFKeyAttribute=true and record KeyField." ],
        "ChildObjects": [ "Detect List<ChildClass> where ChildClass is an owned type.", "For each, create ChildObjectDescription with FieldName, ChildType, IsCollection=true, RelationshipKind=\"Owned\"." ]
      },
      "OutputMapping": {
        "ModelStructureDescriptionFields": [ "ModelName", "Namespace", "QualifiedName", "Domain", "Title", "Help", "Description", "Cloneable", "CanImport", "CanExport", "ListUIUrl", "EditUIUrl", "CreateUIUrl", "InsertUrl", "SaveUrl", "UpdateUrl", "FactoryUrl", "GetUrl", "GetListUrl", "DeleteUrl", "HelpUrl" ],
        "Collections": [ "Properties", "EntityHeaderRefs", "ChildObjects", "Relationships" ],
        "Rule": "All extracted values are projections of existing attributes and resource dictionaries; ModelStructureDescription is a read-only view, not a new source of truth."
      },
      "SeparationFromMetadata": { "Rule": "IDX-0037 (ModelStructureDescription) holds structural shape, relationships, and high-level operational affordances. IDX-0038 will hold detailed UI/validation metadata derived from the same attributes." }
    }
  },
  {
    "Id": "IDX-0037",
    "Title": "Model Structure Description",
    "Status": "Accepted",
    "Description": "Structured chunk for Kind=Model capturing identity, domain, structural graph, properties, entity header references, child objects, relationships, and operational affordances.",
    "ChunkFlavor": "Structured",
    "Fields": [ "ModelName", "Namespace", "QualifiedName", "Domain", "Title", "Help", "Description", "Cloneable", "CanImport", "CanExport", "ListUIUrl", "EditUIUrl", "CreateUIUrl", "HelpUrl", "InsertUrl", "SaveUrl", "UpdateUrl", "FactoryUrl", "GetUrl", "GetListUrl", "DeleteUrl", "Properties", "EntityHeaderRefs", "ChildObjects", "Relationships" ],
    "ImplementationNote": "Data derived from EntityDescription, FormField, LabelResource, HelpResource, FKeyProperty, resource dictionaries, and reflection.",
    "Purpose": "Give the LLM a structural and semantic view of the entity for reasoning and code generation."
  },
  {
    "Id": "IDX-0038",
    "Title": "Model Metadata & UI Description",
    "Status": "Accepted",
    "Description": "Detailed UI, validation, picker, layout, labeling, and metadata for model entities.",
    "ChunkFlavor": "Metadata",
    "Fields": [ "ModelName", "Namespace", "Domain", "ResourceLibrary", "Fields[]" ],
    "FieldSchemaGroups": [ "IdentityAndResources", "DataAndFieldKind", "Validation", "UIBehaviorAndLayout", "ChildAndCollectionSemantics", "PickerAndLookupSemantics", "FileImageAndMedia", "EnumAndOptionsBehavior", "AIAndAdvanced" ],
    "ImplementationSource": "FormFieldAttribute, LabelResource, HelpResource, ResourceType, EnumType, and associated attributes.",
    "Purpose": "Provide full UI/UX metadata contract for generating forms, validation, list views, pickers, and advanced UI behaviors."
  },
  {
    "Id": "IDX-0038",
    "Title": "Model Metadata & UI Description",
    "Status": "Accepted",
    "Description": "Detailed UI, validation, picker, layout, labeling, metadata, and form layouts for model entities, including additional actions.",
    "ChunkFlavor": "Metadata",
    "Fields": [ "ModelName", "Namespace", "Domain", "ResourceLibrary", "Fields[]", "Layouts" ],
    "FieldSchemaGroups": [ "IdentityAndResources", "DataAndFieldKind", "Validation", "UIBehaviorAndLayout", "ChildAndCollectionSemantics", "PickerAndLookupSemantics", "FileImageAndMedia", "EnumAndOptionsBehavior", "AIAndAdvanced" ],
    "Layouts": {
      "Description": "Form and view layouts derived from IFormDescriptor* interfaces and additional action definitions.",
      "Shape": {
        "Form": {
          "Col1Fields": "IFormDescriptor.GetFormFields()",
          "Col2Fields": "IFormDescriptorCol2.GetFormFieldsCol2()",
          "BottomFields": "IFormDescriptorBottom.GetFormFieldsBottom()",
          "TabFields": "IFormDescriptorTabs.GetFormFieldsTabs()"
        },
        "Advanced": {
          "Col1Fields": "IFormDescriptorAdvanced.GetAdvancedFields()",
          "Col2Fields": "IFormDescriptorAdvancedCol2.GetAdvancedFieldsCol2()"
        },
        "InlineFields": "IFormDescriptorInlineFields.GetInlineFields()",
        "MobileFields": "IFormMobileFields.GetMobileFields()",
        "SimpleFields": "IFormDescriptorSimple.GetSimpleFields()",
        "QuickCreateFields": "IFormDescriptorQuickCreate.GetQuickCreateFields()",
        "AdditionalActions": {
          "Source": "IFormAdditionalActions.GetAdditionalActions()",
          "ActionShape": {
            "Title": "string",
            "Icon": "string",
            "Help": "string",
            "Key": "string",
            "ForCreate": "bool",
            "ForEdit": "bool"
          }
        }
      }
    },
    "FormDescriptorInterfaces": [ "IFormDescriptor", "IFormDescriptorCol2", "IFormDescriptorBottom", "IFormDescriptorTabs", "IFormDescriptorAdvanced", "IFormDescriptorAdvancedCol2", "IFormDescriptorInlineFields", "IFormMobileFields", "IFormDescriptorSimple", "IFormDescriptorQuickCreate", "IFormAdditionalActions" ],
    "ImplementationSource": "FormFieldAttribute, LabelResource, HelpResource, ResourceType, EnumType, FormAdditionalAction, and form-descriptor interfaces including IFormDescriptor* and IFormAdditionalActions.",
    "Purpose": "Provide full UI/UX metadata contract for generating forms, validation, list views, pickers, layouts, additional actions, and advanced variants (mobile, simple, quick-create) for model entities."
  },
  {
    "Id": "IDX-0039",
    "Title": "Chunking Strategy for Kind=Manager",
    "Status": "Accepted",
    "Kind": "SourceCode",
    "SubKind": "Manager",
    "Description": "Deterministic, semantics-aware chunking for Manager classes, including overview, per-method chunks, overflow handling, PrimaryEntity detection, and Manager\u2013interface relationships.",
    "ChunkFlavors": [ "ManagerOverview", "ManagerMethod", "ManagerMethodOverflow" ],
    "Ordering": {
      "Rule": "Emit chunks in strict source order per Manager class.",
      "Sequence": [ "ManagerOverview", "ManagerMethod (in source order)", "ManagerMethodOverflow (immediately after owning method)" ],
      "WhyOrderingMatters": [ "Keeps PartIndex/PartTotal stable across runs.", "Reduces unnecessary reembedding and churn.", "Preserves adjacency for multi-chunk methods.", "Improves RAG reconstruction and context for the LLM." ]
    },
    "ManagerOverview": {
      "ChunkFlavor": "ManagerOverview",
      "SymbolType": "Class",
      "Includes": [ "Using directives (optional)", "Namespace declaration", "Class XML docs", "Class attributes", "Class signature (base types and interfaces)", "Private field declarations (signatures only)", "Public/protected properties (signatures only)", "Method index (public methods, signatures only)" ],
      "RequiredMetadata": [ "Kind=SourceCode", "SubKind=Manager", "SymbolType=Class", "ChunkFlavor=ManagerOverview", "PrimaryEntity" ],
      "InterfaceMetadata": {
        "ImplementedInterfaces": "Array of all implemented interfaces by simple type name, e.g., ['IDeviceManager','IDisposable'].",
        "PrimaryInterface": "Primary DI/contract interface when determinable; selected via heuristics: prefer I<ClassName>, then I<PrimaryEntity>Manager, then a unique *Manager interface, else null."
      }
    },
    "ManagerMethod": {
      "ChunkFlavor": "ManagerMethod",
      "SymbolType": "Method",
      "Includes": [ "Method XML docs", "Method attributes", "Full method signature", "Full method body" ],
      "Metadata": {
        "Kind": "SourceCode",
        "SubKind": "Manager",
        "SymbolType": "Method",
        "ChunkFlavor": "ManagerMethod",
        "PrimaryEntity": "Same as overview",
        "MethodKind": "Optional classification such as Create, Update, Delete, Query, Validation, Other."
      }
    },
    "OverflowHandling": {
      "ChunkFlavor": "ManagerMethodOverflow",
      "WhenUsed": "Method body exceeds configured token/size thresholds.",
      "Policy": [ "Never split across method boundaries.", "Split inside method body at safe boundaries (blank lines, regions, comment blocks) when required.", "Primary ManagerMethod chunk contains signature and initial body.", "Overflow chunks contain remaining body content.", "Overflow chunks emitted immediately after their owning ManagerMethod chunk." ],
      "Metadata": {
        "Kind": "SourceCode",
        "SubKind": "Manager",
        "SymbolType": "Method",
        "ChunkFlavor": "ManagerMethodOverflow",
        "OverflowOf": "Name of owning method",
        "PrimaryEntity": "Same as overview"
      }
    },
    "PrimaryEntityDetection": {
      "FieldName": "PrimaryEntity",
      "Description": "Simple class name of the main entity orchestrated by this Manager.",
      "AppliedTo": [ "ManagerOverview", "ManagerMethod", "ManagerMethodOverflow" ],
      "HeuristicsInOrder": [
        {
          "Name": "ClassNamePattern",
          "Rule": "If class name matches '<EntityName>Manager', set PrimaryEntity = EntityName.",
          "Strength": "Strongest"
        },
        {
          "Name": "AddOrCreateFirstParameter",
          "Rule": "If a method starts with Add* or Create* and the first parameter type is an Entity, set PrimaryEntity to that type name.",
          "Strength": "Next strongest"
        },
        {
          "Name": "MethodSignatureDominance",
          "Rule": "Count entity types in method parameters/returns and choose the most frequent when no stronger rule applies.",
          "Strength": "Fallback"
        },
        {
          "Name": "FieldOrPropertyReferences",
          "Rule": "If a single entity type clearly appears in repository/service field names, use that as a final tie-breaker.",
          "Strength": "Final fallback"
        }
      ],
      "AmbiguityHandling": "If no clear dominant entity is found, PrimaryEntity is null.",
      "Rationale": [ "Managers are typically centered on a single entity type.", "PrimaryEntity greatly improves retrieval and cross-linking to model metadata and UI (IDX-0037, IDX-0038).", "The heuristics are deterministic and stable across indexing runs." ]
    },
    "MetadataExpectations": {
      "SharedDocIdPerFile": true,
      "PartIndexPartTotal": "Required for all Manager chunks; assigned using ordering above.",
      "LineStartLineEnd": "Required for text chunks per IDX-020.",
      "CharOffsetsOptional": true
    },
    "Rationale": [ "Manager classes encapsulate workflows and business operations for a primary entity.", "Per-method chunks allow fine-grained reasoning about individual behaviors.", "A class-level overview preserves workflow context and catalog.", "PrimaryEntity connects Manager behavior to model and UI metadata.", "PrimaryInterface and ImplementedInterfaces enable clean cross-linking from Controllers via DI interfaces.", "Stable ordering reduces reindexing cost and enhances RAG quality." ]
  },
  {
    "Id": "IDX-0040",
    "Title": "Chunking Strategy for Kind=Repository",
    "Status": "Accepted",
    "Kind": "SourceCode",
    "SubKind": "Repository",
    "Description": "Deterministic chunking for repository classes, including overview, per-method chunks, overflow handling, and PrimaryEntity detection.",
    "ChunkFlavors": [ "RepositoryOverview", "RepositoryMethod", "RepositoryMethodOverflow" ],
    "Ordering": {
      "Rule": "Emit chunks in strict source order per repository class.",
      "Sequence": [ "RepositoryOverview", "RepositoryMethod (in source order)", "RepositoryMethodOverflow (immediately after owning method)" ],
      "WhyOrderingMatters": [ "Keeps PartIndex/PartTotal stable across runs.", "Reduces unnecessary reembedding and churn.", "Preserves adjacency for multi-chunk methods.", "Improves RAG reconstruction and context for the LLM." ]
    },
    "RepositoryOverview": {
      "ChunkFlavor": "RepositoryOverview",
      "SymbolType": "Class",
      "Includes": [ "Using directives (optional)", "Namespace declaration", "Class XML docs", "Class attributes", "Class signature (base types and interfaces)", "Private field declarations (signatures only)", "Public/protected properties (signatures only)", "Method index (public methods, signatures only)" ],
      "RequiredMetadata": [ "Kind=SourceCode", "SubKind=Repository", "SymbolType=Class", "ChunkFlavor=RepositoryOverview", "PrimaryEntity" ],
      "OptionalStorageProfile": {
        "StorageKind": "DocumentDb|TableStorage|Sql|InMemory|Other",
        "EntityType": "PrimaryEntity or equivalent",
        "CollectionOrTable": "Name when inferable",
        "PartitionKeyField": "Field name when inferable"
      }
    },
    "RepositoryMethod": {
      "ChunkFlavor": "RepositoryMethod",
      "SymbolType": "Method",
      "Includes": [ "Method XML docs", "Method attributes", "Full method signature", "Full method body" ],
      "MethodSelection": [ "Include all public methods.", "Include protected/internal methods when they contain meaningful persistence/query logic.", "Include private methods only when they encapsulate non-trivial behavior." ],
      "Metadata": {
        "Kind": "SourceCode",
        "SubKind": "Repository",
        "SymbolType": "Method",
        "ChunkFlavor": "RepositoryMethod",
        "PrimaryEntity": "Same as overview",
        "MethodKind": "Optional classification such as Query, GetById, Insert, Update, Delete, Upsert, Other."
      }
    },
    "OverflowHandling": {
      "ChunkFlavor": "RepositoryMethodOverflow",
      "WhenUsed": "Method body exceeds configured token/size thresholds.",
      "Policy": [ "Never split across method boundaries.", "Split inside method body at safe boundaries (blank lines, regions, comment blocks) when required.", "Primary RepositoryMethod chunk contains signature and initial body.", "Overflow chunks contain remaining body content.", "Overflow chunks emitted immediately after their owning RepositoryMethod chunk." ],
      "Metadata": {
        "Kind": "SourceCode",
        "SubKind": "Repository",
        "SymbolType": "Method",
        "ChunkFlavor": "RepositoryMethodOverflow",
        "OverflowOf": "Name of owning method",
        "PrimaryEntity": "Same as overview"
      }
    },
    "PrimaryEntityDetection": {
      "FieldName": "PrimaryEntity",
      "Description": "Simple class name of the main entity persisted by this repository.",
      "AppliedTo": [ "RepositoryOverview", "RepositoryMethod", "RepositoryMethodOverflow" ],
      "HeuristicsInOrder": [
        {
          "Name": "BaseClassGenericArgument",
          "Rule": "If repository inherits a generic base such as DocumentDBRepoBase<T> or TableStorageRepoBase<T>, set PrimaryEntity = typeof(T).Name.",
          "Strength": "Strongest"
        },
        {
          "Name": "ClassNamePattern",
          "Rule": "If class name matches '<EntityName>Repository' or '<EntityName>Repo', set PrimaryEntity = EntityName.",
          "Strength": "Strong"
        },
        {
          "Name": "AddInsertUpsertSaveFirstParameter",
          "Rule": "If methods beginning with Add*, Insert*, Upsert*, or Save* exist and their first parameter type is an entity, set PrimaryEntity to that type name.",
          "Strength": "Next strongest"
        },
        {
          "Name": "MethodSignatureDominance",
          "Rule": "Count entity types in method parameters/returns and choose the most frequent when no stronger rule applies.",
          "Strength": "Fallback"
        },
        {
          "Name": "FieldOrPropertyReferences",
          "Rule": "If a single entity type clearly appears in repository/service field/property names, use that as a final tie-breaker.",
          "Strength": "Final fallback"
        }
      ],
      "AmbiguityHandling": "If no clear dominant entity is found, PrimaryEntity is null.",
      "Rationale": [ "Repositories are typically centered on a single entity type.", "PrimaryEntity greatly improves retrieval and cross-linking to model metadata (IDX-0037, IDX-0038).", "The heuristics are deterministic and stable across indexing runs." ]
    },
    "MetadataExpectations": {
      "SharedDocIdPerFile": true,
      "PartIndexPartTotal": "Required for all repository chunks; assigned using ordering above.",
      "LineStartLineEnd": "Required for text chunks per IDX-020.",
      "CharOffsetsOptional": true
    },
    "Rationale": [ "Repository classes encode persistence behavior for entities.", "Per-method chunks allow fine-grained reasoning about individual queries and operations.", "A class-level overview preserves storage context and behavior catalog.", "PrimaryEntity connects repository behavior to model and UI metadata.", "Stable ordering reduces reindexing cost and enhances RAG quality." ]
  },
  {
    "Id": "IDX-0041",
    "Title": "Controller Endpoint Description Chunks",
    "Status": "Accepted",
    "Kind": "SourceCode",
    "SubKind": "Controller",
    "ChunkFlavor": "EndpointDescription",
    "Description": "Defines a 1:1 semantic chunk per HTTP endpoint, capturing identity, linkage to Managers, request/response shape, and authorization metadata for controller actions.",
    "Identity": {
      "Fields": [ "ControllerName", "ActionName", "EndpointKey", "RouteTemplate", "HttpMethods", "ApiVersion", "Area", "PrimaryEntity", "Handler" ],
      "EndpointKeyPattern": "<ControllerName>.<ActionNameWithoutAsyncSuffix>",
      "Handler": {
        "Interface": "DI-injected interface name, e.g. IDeviceManager.",
        "Method": "Handler method name called from the action, e.g. CreateDeviceAsync.",
        "Kind": "Logical handler kind, e.g. Manager."
      }
    },
    "SummaryDescription": {
      "Summary": "One-line human description of the endpoint. Prefer XML <summary>, else synthesize.",
      "Description": "Longer explanation, prefer XML <remarks>, else synthesize.",
      "Tags": "Optional free-form tags for classification, e.g. ['Device','Read','OrgScoped'].",
      "Notes": "Optional list of implementation hints (e.g. uses OrgEntityHeader, wraps in InvokeResult)."
    },
    "RequestShape": {
      "ParameterClassification": [ "Route \u2013 appears in route template or has [FromRoute].", "Query \u2013 has [FromQuery] or is scalar in GET/DELETE by convention.", "Header \u2013 has [FromHeader].", "Body \u2013 complex parameter forming RequestBody.", "Service \u2013 [FromServices] or DI-only types (ignored).", "Unknown \u2013 anything that does not fit the above." ],
      "Parameters": { "Fields": [ "Name (string)", "Source (Route|Query|Header|Unknown)", "Type (string)", "IsRequired (bool)", "IsCollection (bool)", "DefaultValue (string, optional)", "Description (string, optional)" ] },
      "RequestBody": {
        "Fields": [ "ModelType (string)", "IsCollection (bool)", "IsPrimitive (bool)", "ContentTypes (string[])", "Description (string, optional)" ],
        "Cardinality": "Zero or one RequestBody per endpoint."
      }
    },
    "ResponseShape": {
      "ResponsesArray": "One entry per status code returned by the endpoint.",
      "Fields": [ "StatusCode (int)", "Description (string, optional)", "ModelType (string, optional; logical payload type)", "IsCollection (bool, required when ModelType present)", "IsWrapped (bool, optional; true for InvokeResult-style wrappers)", "WrapperType (string, optional; e.g. 'InvokeResult<Device>')", "ContentTypes (string[], optional)", "IsError (bool, optional)", "ErrorShape (string, optional; e.g. 'InvokeResult')" ],
      "Examples": [ "Task<InvokeResult<Device>> => ModelType=Device, IsCollection=false, IsWrapped=true, WrapperType='InvokeResult<Device>'", "Task<InvokeResult<List<Device>>> => ModelType=Device, IsCollection=true, IsWrapped=true, WrapperType='InvokeResult<List<Device>>'" ]
    },
    "Authorization": {
      "Fields": [ "RequiresAuthentication (bool)", "AllowAnonymous (bool)", "Roles (string[], optional)", "Policies (string[], optional)", "Scopes (string[], optional)", "Tenancy (string, optional)" ],
      "TenancyValues": [ "OrgScoped", "UserScoped", "System", "Public" ],
      "RoleSource": "[Authorize(Roles=...)] and similar attributes.",
      "PolicySource": "Authorize(Policy=...) and domain-specific authorization attributes.",
      "ScopeSource": "OAuth/OpenID scope attributes when present."
    },
    "PrimaryEntity": {
      "FieldName": "PrimaryEntity",
      "Description": "Simple class name of the main entity operated on by this endpoint (e.g. Device).",
      "HeuristicSources": [ "Controller name (e.g. DeviceController => Device).", "Route segments (e.g. 'api/devices' => Device).", "Request/response model types.", "Handler Manager's PrimaryEntity when available." ]
    },
    "Ordering": {
      "Rule": "EndpointDescription chunks for a given controller DocId are emitted in source order: controllers in file order, then methods in declaration order.",
      "PartIndexPartTotal": "Assigned using this physical sequence per DocId."
    },
    "Rationale": [ "Provides a single, rich, semantic unit per endpoint for RAG and tooling.", "Connects controllers to Manager and Model metadata via Handler and PrimaryEntity.", "Structured request and response shape supports client generation and testing.", "Authorization metadata enables security-aware reasoning and analysis.", "Design is V1-stable while remaining extensible as real implementation code evolves." ]
  },
  {
    "Id": "IDX-0042",
    "Title": "Interface Overview Chunks",
    "Status": "Accepted",
    "Kind": "SourceCode",
    "SubKind": "Interface",
    "ChunkFlavor": "Overview",
    "Description": "Defines a 1:1 semantic chunk per C# interface, capturing identity, primary entity, methods, and linkage to implementations and controllers.",
    "Identity": {
      "Fields": [ "InterfaceName", "Namespace", "FullName", "IsGeneric", "GenericArity", "BaseInterfaces", "PrimaryEntity", "Role" ],
      "PrimaryEntity": "Simple class name of the primary entity the interface operates on (e.g. Device).",
      "RoleValues": [ "ManagerContract", "RepositoryContract", "ServiceContract", "OtherContract" ]
    },
    "Methods": {
      "Description": "Summarized contract surface of the interface methods.",
      "Fields": [ "Name (string)", "ReturnType (string)", "IsAsync (bool)", "Parameters (array)", "Summary (string, optional)" ],
      "ParameterFields": [ "Name (string)", "Type (string)", "IsOptional (bool)", "DefaultValue (string, optional)" ]
    },
    "Usage": {
      "ImplementedBy": "Array of full class names that implement this interface.",
      "UsedByControllers": "Array of EndpointKeys from IDX-0041 for endpoints that depend on this interface via DI."
    },
    "Ordering": { "Rule": "One InterfaceOverview chunk per interface; chunks within a file are ordered in source order and assigned PartIndex/PartTotal per IDX-019." },
    "Rationale": [ "Provides a compact contract-level description of interfaces.", "Connects interfaces to their implementations and consuming controllers.", "Complements Manager/Repository/Controller DDRs without duplicating UI metadata.", "Supports LLM and tooling scenarios that need to reason about contracts independent of implementations." ]
  }
]
