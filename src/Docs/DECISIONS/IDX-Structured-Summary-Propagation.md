# IDX-Structured Summary Propagation – DDR

## Overview
This decision record defines how **Domain** and **Model** semantic definitions are propagated into all `SummarySection` normalized text for downstream embedding, search, and LLM context.

The goal is to strengthen semantic recall across related artifacts (Models, Managers, Repositories, Services, Controllers, Endpoints, Interfaces) **without polluting embeddings with routing-only metadata**.

This DDR works in tandem with:

- `IDX-StructuredSummary-001 — SummarySection Architecture & Rationale`
- The `SummarySection` class (with metadata fields + normalized text)
- The `RagVectorPayload` + `RagPayloadFactory`

---

## Problem Statement

Embeddings only "see" the `SectionNormalizedText` of each chunk.

If a Manager, Repository, or Controller does not explicitly contain domain or model context in its text, then queries referencing the domain or model may fail to retrieve the correct chunk.

At the same time, duplicating full domain or model descriptions into every section would:

- Waste token budget  
- Create semantic noise  
- Reduce signal from local details

We need a **balanced propagation pattern** that:

1. Ensures Domain & Model are **always present in a light-weight way** in the text.
2. Keeps richer routing/join metadata in **structured fields**, not in the text.

---

## Key Decisions

### Decision 1 — Domain and Model must be textually present in all related sections

Every `SummarySection` belonging to a SubKind that is tied to a domain/model must include:

- A **Domain line** at the top when available:  
  `Domain: {DomainName} — {DomainTagLine}`

- A **Model line** at the top when available:  
  `Model: {ModelNameOrClassName} — {ModelTagLine}`

These lines **seed the semantic embedding** with domain and model context.

Example (intro lines in normalized text for a Manager methods section):

```text
Domain: Device Management — Manage IoT devices and their lifecycle.
Model: Device — Represents an IoT node in the device management domain.

Methods for manager DeviceManager:
...
```

These lines are generated by the `BuildDomainLine` / `BuildModelLine` helpers based on `DomainModelHeaderInformation` and are repeated on each `SummarySection` where needed (e.g., when methods are split into multiple sections due to token budget).

---

### Decision 2 — Use taglines, not full descriptions

We split content into:

- **Domain Overview**: rich, multi-paragraph explanation (stored once, e.g. in a domain document or a dedicated section).
- **Domain TagLine**: 1–2 sentence summary (reused).
- **Model Overview**: rich description (stored in the model section).
- **Model TagLine**: 1–2 sentence summary (reused).

Only **taglines** are reused and propagated into related sections.

In normalized text:

- The **Domain line** uses `DomainName` + `DomainTagLine` (when available).
- The **Model line** uses `ModelName` (or `ModelClassName` as fallback) + `ModelTagLine` (when available).
- Full overviews remain in their own sections (e.g. `model-overview`, domain docs).

---

### Decision 3 — Keep routing metadata out of `SectionNormalizedText`

The following **MUST NOT** appear in `SectionNormalizedText`:

- Repo path, file path, commit SHA  
- Internal IDs (OrgId, ProjectId, DocId, Symbol IDs, etc.)  
- Flavor / SectionType labels (e.g. "Flavor: ManagerDescription")

These fields are instead carried as **structured metadata** and/or payload labels. For example:

- `RagVectorPayload` fields:
  - `OrgId`, `ProjectId`, `ContentTypeId`, `SectionKey`, `Symbol`, `SymbolType`, etc.
- Derived label slugs (via `RagPayloadFactory`):
  - `"ManagerDescription"`, `"section-methods"`, `"domain-AIServices"`, `"model-AgentContextTest"`

This keeps **embeddings clean and semantically meaningful** while giving the reasoner and RagScope rich structural hooks.

---

## SummarySection structure

Logical SummarySection shape for structured ChunkFlavors:

```csharp
public sealed class SummarySection
{
    // What slice of the description this is
    public string SectionKey { get; set; }      // e.g. "model-overview", "manager-methods"
    public string SectionType { get; set; }     // e.g. "Overview", "Methods", "Properties", "Relationships"

    // Which structured flavor produced this
    public string Flavor { get; set; }          // e.g. "ModelStructureDescription", "ManagerDescription"

    // What object this section describes
    public string Symbol { get; set; }          // e.g. "DeviceManager"
    public string SymbolType { get; set; }      // e.g. "Manager", "Model", "Repository"

    // Domain/model coordination hooks
    public string DomainKey { get; set; }       // e.g. "DeviceMgmt", "AIServices"
    public string ModelClassName { get; set; }  // e.g. "Device", "AgentContextTest"
    public string ModelName { get; set; }       // e.g. "Device", "Agent Context"

    // The actual text that gets embedded
    public string SectionNormalizedText { get; set; }
}
```

Only `SectionNormalizedText` is sent to the embedding model. All other fields are used for **metadata, filtering, and reasoning**.

---

## Application to SubKinds

- **Domain**: includes full domain description and tagline
- **Model**: includes domain tagline + full model description and tagline
- **Manager**: includes domain tagline + model tagline
- **Repository**: includes domain tagline + model tagline
- **Controller / Endpoint**: includes domain tagline + model tagline
- **Service**: includes domain tagline; model tagline optional (if tightly scoped to a single model)

---

## Benefits

- Better semantic recall
- Consistent cross-artifact understanding
- Reduced token pollution
- Cleaner embeddings
- Stronger LLM reasoning context
- Natural integration with `RagVectorPayload` + `RagScope`

---

## Status

**Accepted — ready for implementation in all ChunkFlavor builders**